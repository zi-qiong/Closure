# 浅谈闭包与作用域
所谓闭包，官方一点儿的说法就是指有权访问另一个函数作用域的变量的函数。

那么什么又是作用域呢？

JavaScript的作用域有两种，一种是全局作用域，另外一种是局部作用域，也称函数作用域。

全局作用域，顾名思义，在程序执行过程中，全局用域里面定义的变量和方法，可以被任何变量和函数调用和访问，而在函数作用域里面定义的变量和函数，只能在该函数内部进行访问，下面给个例子：

```
let num = 1;
function add(param) {
  ++num;
  let sum = num + param;
  return sum;
}
add(2); //4
console.log(sum); //undefined
console.log(num); //2
```
上面代码中，sum变量是处于函数add内部的一个变量，当函数执行完毕后，在add函数内部定义的变量和方法都会被销毁，所以在函数add执行完成后再次访问add函数内部的变量sum，结果是undefined。

那为什么函数内部能访问全局变量num呢？那么我们引入另一个概念，作用域链。

在每个作用域中，都会有一个与之相对应的变量对象，作用域链是对该作用域下有权访问的变量对象有序的链接起来。

如图所示，在函数add中的作用域链就是把函数add的变量对象和全局变量对象做链接，且函数add的变量对象优先级高于全局变量对象。

函数在访问过程中会根据作用域链里面全局变量对象的优先级去查找，先从函数本身的变量对象中查找是否有需要的变量或函数，如果没有再向上层寻找，如果找到了就返回，如果没有再继续，直到访问全局变量对象。

那如果我们想在函数add外部也能访问变量sum,那我们是不是就没有办法了呢？既然问了，那答案肯定是否定的，这个时候我们就该讲讲我们的闭包了。

所谓闭包，可以理解为函数内部与外部链接起来的一座桥梁，使的函数以外也能访问函数内部的变量。

闭包的常见方式就是在函数内部创建另一个函数。

继续上面的例子做改动，我们用闭包的常见方式改进add函数，获取函数里面的sum，改动如下：

```
let num = 1;
function add(param) {
  ++num;
  let sum = num + param;
  return function(sum) {
    console.log(sum);
  }
}
var sum = add(2);
sum() //4
```
通过上面的方式，我们可以看到，把函数add赋值给全局变量sum时，返回的是一个匿名函数，然后再执行函数sum，照理说，函数add()执行完成后，里面的变量和函数就会被销毁，再次执行函数sum()时，打印的结果应该为undefined，但在闭包中，虽然函数add执行后其中的变量和方法被销毁，但是变量对象依然保存在内存中，所以依然可以被访问，这里引入权威指南里面一句精辟的话 **“Javascript中的函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行”**

对于闭包，我们还经常遇到一个问题，即闭包只能取得包含函数中任意变量的最后一个值，看如下例子：

```
function print() {
    var arr= [];
    for(var i=0; i<3; i++){
        arr[i] = function() {
            return i;
        }
    }
    return arr;
}

print()[0](); //6
print()[1](); //6
print()[2](); //6
```
在上面的写法中，我们的初衷是让函数执行后返回相应的索引值，比如执行print()[0]()返回0，执行print()[1]()返回1，但实际运行的结果是都返回3，我们来讲一下原因：
在上面说的函数销毁的时候，函数当前的执行环节也会被销毁，但是他的活动对象依然被保留在内存中，所以执行函数时，都引用的同一个变量对象中的i，导致执行结果相同。
